Force is being pulled in from a ros node that is outputing LowState.msg from LowState.h in catkin_ws/devel/include.
You will never directly access LowState.h in the project file directory, it has to be generated by catkin_ws from instructions present in unitree_ros_to_real that links them

Force values should be coming in and parsed into individual legs in an array in ucf_go1_control_node.cpp, but only when use_sim is set to false, which is a internal manual change
It should be creating the same vector/array typing that the sim data is formatted as, so it should be fine to use the same control methods for both
For indexing the array for either dataset, it is array= [FL,FR,RL,RR]


The force values get propogated, used, or creates values used in the following structure:

		                         jointTraj -> pub_traj -> ROS Node/Robot Command msg(trajectory_msgs::JointTrajectory)
						            ^
						            |
Everywhere forces get used: getJointTrajectory <- footPosVel -> position/velocity -> joint_positions,jacobians,etc -> F_leg -> jointTorques
									                  ^
									                  |
								                   getFoot <- footPhase_ -> legPhase ->phaseIdx <-> pose.pose
											                      ^
											                      |
                                                            phaseStateMachine <- only to a print statement, 
                                                            but this has all the gait phase controls, so probably really needed but never implemented

Force was never explictly used in any file, but they exist in the ones that forces would have some effect on the output command.

    Force needs to added to: phaseStateMachine primarily from what i can see is what really needs it added, I'm currently unsure of where else might need it.


Also, using footForceEst because it supposedly outputs the force value as an estimated force in Newtons, so we don't have to calibrate the sensors or deal with raw data

Also, I'm unsure because I can't recieve any data from it virtually, but I've only been able to see the existence of the low_state and low_cmd nodes when 
doing roslaunch unitree_legged_real real.launch, with the crtl level parameter set to lowlevel
Otherwise, it appears to run it only at high level, which isn't what we need
And I didn't see either set when running the basic controller setup we've been doing for sims



--- Cameron's new notes ---
This information may not be accurate, but this is what I have found so far.

I found a definition of LowState in unitree_legged_sdk/include/unitree_legged_sdk/comm.h and in it exists both footForce and footForceEst. It says that footForceEst "reserveï¼Œtypically zero", so we probably want to footForce instead. This can be toggled in go1_hw_interface.h by changing use_footForceEst_

How to test latest changes (of getting foot force data):
1. start hardware node
	- This might be the command: roslaunch ucf_go1_bringup go1_hw.launch

2. list topics and confirm the publishers exist
	- rostopic list | egrep -i '/visual/.*foot_contact/the_force' || true

3. inspect a message
	- rostopic echo -n1 /visual/FL_foot_contact/the_force # FL foot as example, can also use FR, RL, or RR
	- there should be a wrench.force.z which should contain the raw sensor value times scale +/- offset (scale, offset, and sign can be set in go1_hw_interface.h or by setting them via rosparam)